#!/usr/bin/env guile
!# ;; -*- mode: Scheme;-*-
;;;; Copyright (c) 2007 Leonardo Valeri Manera <lvalerimanera>@{NOSPAM}<google.com>
;;;; This program is licensed under the terms of the General Public License version 2.
;;;; Based on the portage script emwrap.sh, (c) 2004-2007 Hiel Van Campen.

;; PALUDIS_OPTIONS="" paludis -pi1 --dl-deps-default discard --show-reasons none --show-use-descriptions none --checks none $toolchain
;; PALUDIS_OPTIONS="" paludis -pi1 --dl-deps-default discard --show-reasons none --show-use-descriptions none --checks none --resume-command-template /var/tmp/properize-resume system|everything

;;; Load the configuration file
;; FIXME: This is bloody dangerous, make a fucking parser already.
;; FIXMETOO: Mebbe this should be below ze global var defs, hmmm?
;(load "/etc/properize.conf")
(define debug #t)

;;; Turn debugging on up here, so it takes effect immediately
;;; if set in configuration file.
(if debug
    (debug-enable 'backtrace))

;;; Global variables and constants
;; The version of the application, duh.
(define *properize-version* '(0 0 1))
;; The earlist compatible version, as far as internal structure of the state alist goes
(define *compatible-version* '(0 0 1))
;; The location of the configuration file.
(define *system-configuration-file* "/etc/properize.conf")
;; Happy happy joy joy... hey, perhaps a . should be prepended if
;; (string=? *state-dir* (env home))? Discuss.
;(define *state-file* (string-append *state-dir* "/properize-resume"))
;; Yay global variables, what is this, java???
(define verbose #t)
(define pretend #t)
(define upgrade #t)
(define pre-dependencies "discard")
(define checks "none")

;;; Load necessary modules
;; We need regular expressions.
(use-modules (ice-9 regex))
;; Getopt-long provides a method to parse standard UNIX-style command-line options.
(use-modules (ice-9 getopt-long))
;; Optional & Keyword arguments sugar. Mmmmm, sugar.
(use-modules (ice-9 optargs))
;; Provides interface to POSIX system calls.
(use-modules (ice-9 posix))
;; Provides POSIX pipes.
(use-modules (ice-9 popen))
;; receive and let-values
(use-modules (ice-9 receive))
(use-modules (srfi srfi-11))

;;; Display functions
;; Prints version and basic copyright information.
(define (print-header)
  (begin (display "Properize v")
	 (display (version->string *properize-version*))
	 (display " (") (display (car (command-line))) (display ")\n")
	 (display "Copyright (c) 2007 Leonardo Valeri Manera <lvalerimanera>@{NOSPAM}google.com\n")
	 (display "This program is licensed under the terms of the GPL version 2.\n")
	 (display "Based on the portage script emwrap.sh, (c) 2004-2007 Hiel Van Campen.\n\n")))
;; Prints the good old --help dialogue.
(define (print-help)
  (display"\
Usage: properize [OPTION] [SETS]
Make installation consistent with toolchain.
Example: properize -s
       properize [OPTION] --resume
Resume an interrupted operation.

Option arguments must follow the option immediately if specified:
  -f bar
In the long form, both
  --foo=bar
and
  --foo bar
are valid.

-General options
  -v --version           Display version.
  -h --help              Display this help.
  -V --verbose           Print information about each step - useful for debugging.

-Action options
  -r --resume            Resume an interrupted operation.
  -p --pretend           Pretend only.
  -u --upgrade           Passes --dl-upgrade always to paludis during set
                         package-list generation.
     --pre-dependencies=deptype
                         Passes the supplied value as argument to
                         --dl-installed-deps-pre to paludis *AS_IS*
                         during set package-list generation.
                         Defaults to \"discard\".
     --checks=runopt     Passes the supplied value as an argument to
                         --checks to paludis *AS_IS* during build
                         operations.
                         Defaults to \"none\".

-Set Package-list generation options
  -t --toolchain=TYPE    Rebuild toolchain. This is *ALWAYS* on. Use option to
                         specify the toolchain rebuild. See below.
  -s --system            Rebuild set:system after the toolchain.
  -e --everything        Rebuild set:everything after the system. Implies system.

This is not a general-operation wrapper script, it is merely
intended to help in making one's installation consistent after
a toolchain or C/CXX/LDFLAG change.
During package-list generation, \"toolchain\" is subtracted from \"system\",
and \"system\" from \"everything\", in order to remove unnecessary
compilation and minimize execution time.

Various \"toolchain\" operations are available, the default can be overridden
by passing their names as arguments to the toolchain option:

  properize -et gcc-single

  properize --system --toolchain=binutils-single

and so on.

The toolchain operation types, and the packages that will be rebuilt,
in order, are:

Full rebuilds:

  headers          =\"linux-headers glibc binutils gcc glibc binutils gcc\" (default)
  glibc            =\"glibc binutils gcc glibc binutils gcc\"
  binutils|gcc     =\"binutils gcc binutils gcc\"

Single builds:

  headers-single        =\"linux-headers glibc binutils gcc\"
  glibc-single          =\"glibc binutils gcc\"
  binutils|gcc-single   =\"binutils gcc\"

After the standard toolchain list is generated, some packages are appended if they exist:

  libtool
  libstdc++-v3

Currently, the toolchain builds are lifted straight out of emwrap.sh,
Copyright (c) 2004-2007 Hiel Van Campen.
If you have a better idea, I'm open to suggestions.\n\n"))
;; Prints the salient points of the current internal state, moderately prettily.
(define (print-state)
  (begin (display "State:")
	 (display "\n  Toolchain: ") (display (state 'toolchain))
	 (display "\n  System: ") (display (state 'system))
	 (display "\n  Everything: ") (display (state 'everything))
	 (display "\n  Progress: ") (display (state 'progress)) (newline)))

;;; Convenience functions
;; Takes a tripartite version, makes it printable.
;; <version> must be a list of 3 numbers.
;; Returns a string.
(define (version->string version) (string-append (number->string (car version)) "."
						 (number->string (cadr version)) "."
						 (number->string (caddr version))))

;;; Define the "state" alist, and the shortcut functions to read and write to its values
;; Hashes sound nice, except opaque hashes can't be written to file, and concrete hashes are
;; horribly buggy - empty cells all over the place.
;; Alists might not be fast if they're huge, but they're fine for this - what will be large will
;; be the cdr of some of the cells. Mise store those in vektorz?
(define state-alist `((version . ,*properize-version*)
		      (toolchain . "no")
		      (toolchain-apps . (""))
		      (system . #f)
		      (system-apps . (""))
		      (everything . #f)
		      (everything-apps . (""))
		      (progress . "Initilization")
		      (todo . (""))))
;; Getter/Setter for state-type alists
;; Getter:
;; <key> must be a symbol, a la 'bob.
;; <obj> is optional, must be a symbol pointing to a state alist.
;; Returns the value of the cell with the given key, or #f if it does not exist - which is only
;; useful for reading resume states with possibly missing cells.
;; Usage: (state <key> [<val>])
;; Setter:
;; <key> must be a symbol, a la 'bob.
;; <val> is the value that will be dumped in the cdr of the cell, can be anything really.
;; Usage: (set! (state <key>) <val>)
(define state (make-procedure-with-setter
	       ; Read from resume-file state-alists with this.
	       ; Returns #f if the key is not present, for soft-falure on
	       ; outdated resume-files that have usable data in other keys.
	       (lambda* (key #:optional (obj state-alist))
		   (let ((val (assoc key obj)))
		     (if (boolean? val)
			 #f
			 (cdr val))))
	       ; No changing values in the resume state, that's read-only =p
	       ; All changes happen in the current state, which gets written
	       ; to file before a package operation.
	       (lambda* (key val)
		   (set! obj (assoc-set! state-alist key val)))))

;(set! state-alist (assoc-set! state-alist 'todo '((paludis . "gcc") (gcc-config . "4.1.2") (paludis . "glibc"))))
;(equal? (caar (assoc-ref state-alist 'todo)) 'paludis) => #t

;;; Resume-State reading and writing
;; Reads the alist from the state-file, and loads its values into the
;; current state alist.
;; If the version that created the file is below the last compatible version,
;; error out and die.
;; Returns undefined.
;; FIXME: Needs predicates for the type of values in cells, mmmmaybe?
(define (resume-read)
  (let ((resume-alist (with-input-from-file *state-file* (lambda () (read)))))
    (if (and (>= (car (state 'version resume-alist)) (car *compatible-version*))
	     (>= (cadr (state 'version resume-alist)) (cadr *compatible-version*))
	     (>= (caddr (state 'version resume-alist)) (caddr *compatible-version*)))
	(do ((state-var-list '('version
			       'toolchain
			       'toolchain-apps
			       'system
			       'system-apps
			       'everything
			       'everything-apps
			       'progress
			       'todo) (cdr state-var-list)))
	    ((null? state-var-list))
	  (let ((state-var (car state-var-list)))
	    (if (not (boolean? (state state-var resume-alist)))
		(set! (state state-var) (state state-var resume-alist)))))
	(begin (display "\nSorry, the resume file was created by an incompatible version of properize.\n")
	       (exit)))))
;; Nothing fancy, just dumps the current alist to file, packaged in a thunk
;; for code readability.
;; Returns undefined.
(define (resume-write)
      (with-output-to-file *state-file* (lambda () (write state-alist))))

;;; General command handlers
;; Encapsulate :eval-exit so we can simply run paludis-execute-action as a condition.
;; <action> must be a string.
;; Returns a boolean (obviously).
(define (system-execute-action action)
  (if (= 0 (status:exit-val (system action)))
      #t
      #f))

;;; (gcc|binutils)-config handlers
;; much, MUCH later.
;gcc-config i686-pc-linux-gnu-4.1.2
;$(source /etc/paludis/bashrc 2>/dev/null; echo $CHOST)
;(match:substring (string-match "^(sys-devel/gcc-)([.0-9r]+(-r[0-9])?)(.*)$" package) 2)

;;; Paludis handlers
;; Generates a command  that can be passed as an argument to system-execute-action to build a
;; package.
;; <package> must be a string.
;; Returns a string.
(define (paludis-generate-command package)
  (let ((command "PALUDIS_OPTIONS=\"\" paludis "))
    (if pretend
	(set! command (string-append command "-pi1 "))
	(set! command (string-append command "-i1 ")))
    (if upgrade
	(set! command (string-append command "--dl-upgrade always ")))
    (set! command (string-append command package))
    command))
;; Given a target, generates a list of the packages to be installed.
;; <target> must be a string. It better be a valid set or pakage, yo =P
;; Returns a list, '() in case the target is invalid - or in case of any other failure along the
;; way, tbqh.
;; FIXME: Gotta figure out a way to make it more debuggable. How expensive would it be to
;; implement w. inbuilt Regexp & String-ops?
;; Guile bidirectional pipes do not a good text filter make.
(define (paludis-extract-packages target upgrade pre-dependencies)
  (let* ((command (string-append "PALUDIS_OPTIONS=\"\" "
				 "paludis -pi "
				 (if upgrade
				     "--dl-upgrade always "
				     "--dl-upgrade as-needed ")
				 "--dl-installed-deps-pre " pre-dependecies " "
				 target
				 " | egrep \"\\[(([RN])|(U [-_.[:alnum:]]+))\\]\""
				 " | awk '{print $2}'"))
	 (port (open-input-pipe command))
	 (package-list '("")))
    (do ((package (read port) (read port)))
	((eof-object? package) (close-pipe port) (if (not (null? (cdr package-list)))
						     (cdr package-list)
						     '()))
      (append! package-list `(,(symbol->string package))))))

;;; Action-list execution
;; Iterates over the action list, saving it to disk before running it.
(define (execute-action-list action-list) "stub")

;;; Generator -  does what it says on the box ;)
;; Generates a list of actions and passes it to executor.
(define (generate-action-list toolchain system everything upgrade pre-dependencies checks) "stub")

;;; Validity predicates
(define (valid-toolchain-option? arg)
  (regexp-match? (string-match "^((headers|gcc|binutils|glibc){1}(-single)?)$" arg)))
(define (valid-configuration-file? file)
  (if (and (access? file R_OK)
	   (= 0 (status:exit-val (string-append "source " file))))
      #t
      #f))
;; Simple check for the state-dir.
;; Returns boolean; true if the dir is read/writeable and we can create files, and
;; either the file does not exist, or it exists and we have read/write
;; access on it, otherwise returns false.
;; FIXME: must do better, eat more cake.
(define (valid-resume-location? state-dir)
  (if (and (access? state-dir (logior R_OK W_OK X_OK))
	   (or (not (access? state-file F_OK))
	       (access? state-file (logior W_OK R_OK))))
      #t
      #f))

;;; Configuration file functions
;; Reads a configuration file, checking for the validity of the options therein.
;; <file> must be a string, and better be a valid filename-cum-path too.
;; Returns 2 values, the resume-directory and the default-toolchain.
;; You'll need to use (receive) or similar.
(define (read-configuration-file file)
  (let* ((source-string (string-append "source " file " 2>/dev/null; echo $"))
	 (retrieve-variable (lambda (var)
			      (let* ((port (open-input-pipe (string-append source-string
									   var)))
				     (shell-var (read port)))
				(close-pipe port)
				shell-var)))
	 (resume-directory (retrieve-variable "RESUME_FILE"))
	 (default-toolchain (retrieve-variable "DEFAULT_TOOLCHAIN")))
    (if (not (valid-resume-location? resume-directory))
	(begin (display "\nThere's a problem with your resume-location.\n")
	       (display "Check your configuration file and/or permissions.\n")
	       (exit)))
    (if (not (valid-toolchain-option? default-toolchain))
	(begin (display "\n\"") (display default-toolchain) (display"\"")
	       (display " is not a valid toolchain option.\n") (exit)))
    (values resume-directory default-toolchain)))

;;; Argument parser
(define (parse-arguments)
  (let* ((option-spec `((help (single-char #\h) (value #f))
			(version (single-char #\v) (value #f))
			(pretend (single-char #\p) (value #f))
			(verbose (single-char #\V) (value #f))
			(upgrade (single-char #\u) (value #f))
			(pre-dependencies (value #t))
			(checks (value #t))
			(resume (single-char #\r) (value #f))
			(toolchain (single-char #\t) (value #t)
				   (predicate ,valid-toolchain-option?))
			(system (single-char #\s) (value #f))
			(everything (single-char #\e) (value #f))))
	 (options (getopt-long (command-line) option-spec))
	 (help-wanted (option-ref options 'help #f))
	 (version-wanted (option-ref options 'version #f))
	 (pretend-wanted (option-ref options 'pretend #f))
	 (verbose-wanted (option-ref options 'verbose #f))
	 (upgrade-wanted (option-ref options 'upgrade #f))
	 (pre-dependencies-wanted (option-ref options 'pre-dependencies "discard"))
	 (checks-wanted (option-ref options 'checks "none"))
	 (resume-wanted (option-ref options 'resume #f))
	 (toolchain-wanted (option-ref options 'toolchain "headers"))
	 (system-wanted (option-ref options 'system #f))
	 (everything-wanted (option-ref options 'everything #f)))
    ;; Check for these before anything else.
    (if help-wanted
	(begin (print-header) (print-help) (exit)))
    (if version-wanted
	(begin (print-header) (exit)))
    (if verbose-wanted (set! verbose #t))
    ;; If we got told to resume, read the state file into the alist.
    (if resume-wanted
	(begin (if verbose (display "\nResuming...\n"))
	       (let-values* ((() ()))
			    )
	       (resume-read)
	       (if verbose-wanted
		   (begin (newline) (print-state) (newline)))
	       (executor))
	;; I should create bidirectional conversion functions for these, so I can get rid
	;; of these inline (cond)s...
	(set! pretend pretend-wanted)
	(set! upgrade upgrade-wanted)
	(set! pre-dependecies pre-dependecies-wanted)
	(set! checks checks-wanted)
	(set! (state 'everything) everything-wanted)
	(set! (state 'system) (if everything-wanted
				  #t
				  system-wanted))
	(set! (state 'toolchain) toolchain-wanted)
	(set! (state 'progress) "Options Parsed")
	(if verbose-wanted
	    (begin (newline) (print-state) (newline)))
	(generator))))

;;; The world is burning, run!
;; Check if everything is allright with the environment.
(define (check-environment)
  ;; check that the state-dir variable points to a valid location.
  (if (not (valid-configuration-file? *system-configuration-file*))
      (begin (display "\nThere is a problem with the configuration file;\n")
	     (display "Please check your syntax.\n")
	     (exit)))
  (if (null? (cdr (command-line))) ; if called w. no arguments, print help and exit.
      (begin (print-header) (print-help) (exit))
      (begin (if verbose (display "\nParsing command-line...\n"))
	     (parse-options))))

;;; Program starts on last line *g*
(check-environment)

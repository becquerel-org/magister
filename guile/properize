#!/usr/bin/env guile
!# ;; -*- mode: Scheme;-*-
;;;; Copyright (c) 2007 Leonardo Valeri Manera <lvalerimanera>@{NOSPAM}<google.com>
;;;; This program is licensed under the terms of the General Public License version 2.
;;;; Based on the portage script emwrap.sh, (c) 2004-2007 Hiel Van Campen.

;; PALUDIS_OPTIONS="" paludis -pi1 --dl-deps-default discard --show-reasons none --show-use-descriptions none --checks none $toolchain
;; PALUDIS_OPTIONS="" paludis -pi1 --dl-deps-default discard --show-reasons none --show-use-descriptions none --checks none --resume-command-template /var/tmp/properize-resume system|everything

;;; Turn debugging on up here, so it takes effect immediately.
(debug-enable 'backtrace)

;;; Global variables and constants
;; The version of the application, duh.
(define *properize-version* "0.0.2")
;; The location of the configuration file.
(define *system-configuration-file* "/etc/properize.conf")
;; Yay global variables, what is this, java???
(define verbose #t)

;;; Load necessary modules
;; We need regular expressions.
(use-modules (ice-9 regex))
;; Getopt-long provides a method to parse standard UNIX-style command-line options.
(use-modules (ice-9 getopt-long))
;; Optional & Keyword arguments sugar. Mmmmm, sugar.
(use-modules (ice-9 optargs))
;; Provides POSIX pipes.
(use-modules (ice-9 popen))
;; receive and let-values
(use-modules (ice-9 receive))
(use-modules (srfi srfi-11))

;;; Display functions
;; Prints version and basic copyright information.
(define (print-header)
  (begin (display "Properize v")
	 (display *properize-version*)
	 (display " (") (display (car (command-line))) (display ")\n")
	 (display "Copyright (c) 2007 Leonardo Valeri Manera ")
	 (display "<lvalerimanera>@{NOSPAM}google.com\n")
	 (display "This program is licensed under the terms of the GPL version 2.\n")
	 (display "Based on the portage script emwrap.sh, (c) 2004-2007 Hiel Van Campen.\n\n")))

;; Prints the good old --help dialogue.
(define (print-help)
  (display"\
Usage: properize [OPTION] [SETS]
Make installation consistent with toolchain.
Example: properize -s
       properize [OPTION] --resume
Resume an interrupted operation.

Option arguments must follow the option immediately if specified:
  -f bar
In the long form, both
  --foo=bar
and
  --foo bar
are valid.

-General options
  -v --version           Display version.
  -h --help              Display this help.
  -V --verbose           Print information about each step - useful for debugging.

-Action options
  -r --resume            Resume an interrupted operation.
  -p --pretend           Pretend only.
  -u --upgrade           Passes --dl-upgrade always to paludis during set
                         package-list generation.
     --pre-dependencies=deptype
                         Passes the supplied value as argument to
                         --dl-installed-deps-pre to paludis *AS_IS*
                         during set package-list generation.
                         Defaults to \"discard\".
     --checks=runopt     Passes the supplied value as an argument to
                         --checks to paludis *AS_IS* during build
                         operations.
                         Defaults to \"none\".

-Set Package-list generation options
  -t --toolchain=TYPE    Rebuild toolchain. This is *ALWAYS* on. Use option to
                         specify the toolchain rebuild. See below.
  -s --system            Rebuild set:system after the toolchain.
  -e --everything        Rebuild set:everything after the system. Implies system.

This is not a general-operation wrapper script, it is merely
intended to help in making one's installation consistent after
a toolchain or C/CXX/LDFLAG change.
During package-list generation, \"toolchain\" is subtracted from \"system\",
and \"system\" from \"everything\", in order to remove unnecessary
compilation and minimize execution time.

Various \"toolchain\" operations are available, the default can be overridden
by passing their names as arguments to the toolchain option:

  properize -et gcc-single

  properize --system --toolchain=binutils-single

and so on.

The toolchain operation types, and the packages that will be rebuilt,
in order, are:

Full rebuilds:

  headers          =\"linux-headers glibc binutils gcc glibc binutils gcc\" (default)
  glibc            =\"glibc binutils gcc glibc binutils gcc\"
  binutils|gcc     =\"binutils gcc binutils gcc\"

Single builds:

  headers-single        =\"linux-headers glibc binutils gcc\"
  glibc-single          =\"glibc binutils gcc\"
  binutils|gcc-single   =\"binutils gcc\"

After the standard toolchain list is generated, some packages are appended if they exist:

  libtool
  libstdc++-v3

Currently, the toolchain builds are lifted straight out of emwrap.sh,
Copyright (c) 2004-2007 Hiel Van Campen.
If you have a better idea, I'm open to suggestions.\n\n"))

;;; Pipe-reading
;; Runs a pipe an input pipe and returns the result - one line only.
;; <command> must be a string and a valid sh pipe.
;; Returns whatever was in the 1st line of pipe's output, raw;
;; typechcking is left to the receiver.
(define (read-pipe-line command)
  (let* ((port (open-input-pipe command))
	 (pipe-line (read port)))
    (close-pipe port)
    pipe-line))

;; Reads a $var from a file, and returns its result.
;; <var> must be a string, the name of the $var you want to retrieve, sans the $
;; <file> must be a valid file identifier, either a file object or a string.
;; Returns whatever was in the $var, as a string.
(define (read-$var-from-file var file)
  (let* ((source-echo-command (string-append "source " file " 2>/dev/null; echo $" var))
	 (value (read-pipe-line source-echo-command)))
    (cond ((symbol? value) (symbol->string value))
	  ((number? value) (number->string value))
	  (else value))))

;;; Resume-file reading and writing
;; Reads the action-list from the resume-file, and returns it.
;; <resume-file> must be a string pointing to a file, or a readable file port.
;; Returns a list.
(define (resume-read resume-file)
  (let ((action-list (with-input-from-file resume-file (lambda () (read)))))
    action-list))

;; Nothing fancy, just dumps the action-list into a file.
;; <resume-file> must be a string pointing to a file, or a readable file port.
;; <action-list> better be the list you wanna write to the resume-file
;; Returns undefined.
(define (resume-write resume-file action-list)
  (with-output-to-file resume-file (lambda () (write action-list))))

;;; General command handlers
;; Encapsulate :eval-exit so we can simply run paludis-execute-action as a condition.
;; <action> must be a string.
;; Returns a boolean (obviously).
(define (system-execute-action action)
  (if (= 0 (status:exit-val (system action)))
      #t
      #f))

;;; (gcc|binutils)-config handlers
;; much, MUCH later.
;gcc-config i686-pc-linux-gnu-4.1.2
;$(source /etc/paludis/bashrc 2>/dev/null; echo $CHOST)
;(match:substring (string-match "^(sys-devel/gcc-)([.0-9r]+(-r[0-9])?)(.*)$" package) 2)

;;; Paludis handlers
;; Generates a command that can be passed as an argument to system-execute-action to build a
;; package.
;; <package> must be a string.
;; Returns a string.
(define (paludis-generate-command package pretend upgrade checks)
  (string-append "paludis "
		 (if pretend
		     "-pi1 "
		     "-i1 ")
		 "--checks " checks " "
		 (if upgrade
		     "--dl-upgrade always "
		     "--dl-upgrade as-needed ")
		 package))

;; Given a target, generates a list of the packages to be installed.
;; <target> must be a string. It better be a valid set or pakage, yo =P
;; Returns a list, '() in case the target is invalid - or in case of any other failure along the
;; way, tbqh.
;; FIXME: Gotta figure out a way to make it more debuggable. How expensive would it be to
;; implement w. inbuilt Regexp & String-ops?
;; Guile bidirectional pipes do not a good text filter make.
(define* (paludis-extract-packages target upgrade pre-dependencies #:optional (toolchain . #f))
  (let* ((command (string-append "paludis -pi "
				 (if upgrade
				     "--dl-upgrade always "
				     "--dl-upgrade as-needed ")
				 (if toolchain
				     "--dl-deps-default discard "
				     "--dl-installed-deps-pre " pre-dependecies " ")
				 target
				 " | egrep '^\\* .*/.* '"
				 " | awk '{print $2}'"))
	 (port (open-input-pipe command))
	 (package-list '("")))
    (do ((package (read port) (read port)))
	((eof-object? package) (close-pipe port) (cdr package-list))
      (append! package-list `(,(symbol->string package))))))

;;; Action-list execution
;; Iterates over the action list, saving it to disk before running it.
(define (execute-action-list action-list) "stub")

;;; Generator -  does what it says on the box ;)
;; Generates a list of actions and passes it to execute-action-list.
(define (generate-action-list toolchain system everything pretend
			      upgrade pre-dependencies checks chost) "stub")

;;; Validity predicates
;; Checks wether the given option is a valid toolchain-action spec.
;; <arg> must be a string.
;; Returns boolean.
(define (valid-toolchain-option? arg)
  (regexp-match? (string-match "^((headers|gcc|binutils|glibc){1}(-single)?)$" arg)))

;; Checks a configuration file for problems.
;; <file> must be a string.
;; Returns boolean.
;; FIXME: Split one for existence, the other for syntax.
(define (valid-configuration-file? file)
  (if (and (access? file R_OK)
	   (= 0 (status:exit-val (system (string-append "source " file)))))
      #t
      #f))

;; Simple check for the state-dir.
;; Returns boolean; true if the dir is +rwx to us, otherwise returns false.
;; FIXME: does not work with SUID/SGID, implement an exception-catching try-fail
;; tester.
(define (valid-resume-directory? dir)
  (if (access? dir (logior R_OK W_OK X_OK))
      #t
      #f))

;; Simple check for the state-file.
;; Returns boolean; true if the file either does not exist, or does and is +rw to us,
;; otherwise returns false.
;; FIXME: seee (valid-resume-directory?)
(define (valid-resume-file? file)
  (if (or (not (access? state-file F_OK))
	  (access? state-file (logior W_OK R_OK)))
      #t
      #f))

;;; Configuration file parser.
;; Reads a configuration file, checking for the validity of the options therein.
;; <file> must be a string, and better be a valid filename-cum-path too.
;; Returns 3 values, the resume-directory, the default-toolchain, and the CHOST.
;; You'll need to use (receive) or similar.
(define (read-configuration-file file)
  (let* ((resume-file (read-$var-from-file "RESUME_FILE" file))
	 (default-toolchain (read-$var-from-file "DEFAULT_TOOLCHAIN" file))
	 (default-toolchain-ok (valid-toolchain-option? default-toolchain))
	 (resume-directory
	  (match:substring (string-match "^(/.*)(/)(.*)$" resume-file) 1))
	 (resume-directory-ok (valid-resume-directory? resume-directory))
	 (resume-file-ok (valid-resume-file? resume-file))
	 (paludis-bashrc (read-$var-from-file "PALUDIS_BASHRC" file))
	 (chost (read-$var-from-file "CHOST" paludis-bashrc))
	 (chost-ok (not (eof-object? chost))))
    (cond ((and (not resume-directory-ok)
		(not resume-file-ok))
	   (begin (display "\nThere's a problem with the resume-file you specified:\n")
		  (display "Properize needs +rwx permissions to the containing directory, ")
		  (display "and +rw to the file you named.\n") (exit)))
	  ((not resume-file-ok)
	   (begin (display "\nThere's a problem with the resume-file you specified:\n")
		  (display "Properize needs +rw permissions to the file you named.\n") (exit)))
	  ((not resume-directory-ok)
	   (begin (display "\nThere's a problem with the resume-file you specified:\n")
		  (display "Properize needs +rwx permissions to the containing directory.\n")
		  (exit))))
    (if (not default-toolchain-ok)
	(begin (display "\n\"") (display default-toolchain) (display"\"")
	       (display " is not a valid toolchain option.\n") (exit)))
    (if (not chost-ok)
	(begin (display "\nPaludis' bashrc does not contain a CHOST variable.\n")
	       (display "Please set one and try again, kthnx.\n") (exit)))
    (values resume-file default-toolchain chost)))

;;; Command-line option parser
(define (parse-commandline default-toolchain)
  (let* ((option-spec `((help (single-char #\h) (value #f))
			(version (single-char #\v) (value #f))
			(pretend (single-char #\p) (value #f))
			(verbose (single-char #\V) (value #f))
			(upgrade (single-char #\u) (value #f))
			(pre-dependencies (value #t))
			(checks (value #t))
			(resume (single-char #\r) (value #f))
			(toolchain (single-char #\t) (value #t)
				   (predicate ,valid-toolchain-option?))
			(system (single-char #\s) (value #f))
			(everything (single-char #\e) (value #f))))
	 (options (getopt-long (command-line) option-spec))
	 (help-wanted (option-ref options 'help #f))
	 (version-wanted (option-ref options 'version #f))
	 (pretend-wanted (option-ref options 'pretend #f))
	 (verbose-wanted (option-ref options 'verbose #f))
	 (upgrade-wanted (option-ref options 'upgrade #f))
	 (pre-dependencies-wanted (option-ref options 'pre-dependencies "discard"))
	 (checks-wanted (option-ref options 'checks "none"))
	 (resume-wanted (option-ref options 'resume #f))
	 (toolchain-wanted (option-ref options 'toolchain default-toolchain))
	 (system-wanted (option-ref options 'system #f))
	 (everything-wanted (option-ref options 'everything #f)))
    (values help-wanted
	    version-wanted
	    pretend-wanted
	    verbose-wanted
	    upgrade-wanted
	    pre-dependencies-wanted
	    checks-wanted
	    resume-wanted
	    toolchain-wanted
	    system-wanted
	    everything-wanted)))

;;; Argument parser
(define (parse-options configuration-file)
  (let-values* (((resume-file
		  default-toolchain
		  chost) (read-configuration-file configuration-file))
		((help-wanted
		  version-wanted
		  pretend-wanted
		  verbose-wanted
		  upgrade-wanted
		  pre-dependencies-wanted
		  checks-wanted
		  resume-wanted
		  toolchain-wanted
		  system-wanted
		  everything-wanted) (parse-commandline default-toolchain)))
	       ;; Check for these before anything else.
	       (if help-wanted
		   (begin (print-header) (print-help) (exit)))
	       (if version-wanted
		   (begin (print-header) (exit)))
	       (if verbose-wanted (set! verbose #t))
	       ;; Regardless, we clear the PALUDIS_OPTIONS env var.
	       (unsetenv "PALUDIS_OPTIONS")
	       (if resume-wanted
		   ;; If we got told to resume, read the state file and pass the action-list
		   ;; to (execute-action-list).
		   (let ((action-list (resume-read resume-file)))
		     (if verbose (display "\nResuming...\n"))
		     (execute-action-list action-list))
		   ;; Else, proceed with potion mangling and action-list generation.
		   (let ((system-wanted (if everything-wanted
					     #t
					     system-wanted)))
		     (if verbose (display "\nInitializing...\n"))
		     (generate-action-list toolchain-wanted
					   system-wanted
					   everything-wanted
					   pretend-wanted
					   upgrade-wanted
					   pre-dependencies-wanted
					   checks-wanted
					   chost)))))

;;; The world is burning, run!
(define (check-environment)
  ;; check that the state-dir variable points to a valid location.
  (if (not (valid-configuration-file? *system-configuration-file*))
      (begin (display "\nThere is a problem with the configuration file;\n")
	     (display "Please check your syntax.\n")
	     (exit)))
  (if (null? (cdr (command-line))) ; if called w. no arguments, print help and exit.
      (begin (print-header) (print-help) (exit))
      (parse-options *system-configuration-file*)))

;;; Program starts on last line *g*
(check-environment)
